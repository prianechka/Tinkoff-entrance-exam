\documentclass[a4paper,14pt, unknownkeysallowed]{extreport}
\usepackage{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\begin{document}
\tableofcontents

\chapter{Запуск игры}
Чтобы запустить игру, нужно запустить main.py. 
Из сторонних библиотек потребуется только numpy.

\chapter{Создание игры}
В меню игрок может выбрать один из пунктов меню:
\begin{enumerate}
	\item 1 - Простой режим.
	\item 2 - Пользовательский режим.
	\item 3 - Загрузить игру
	\item 0 - Выйти
\end{enumerate}

В простом режиме автоматически генерируется поле размером 5x5.
Количество бомб генерируется случайным образом от 2 до 5.
Бомбы расставляются ещё до первого хода, поэтому игрок может проиграть первым же ходом.

В пользовательском режиме пользователь дополнительно вводит размер поля (не меньше 5 по каждому из измерений), а также количество бомб (не менее 2).
Проверка ввода присутствует, в случае чего программа будет запрашивать данные до тех пор, пока пользователь не введёт корректные значения.

\chapter{Игра}
Во время игры игрок после каждого хода видит карту, где клетка принимает одно из значений
\begin{itemize}
	\item Цифра от 0 до 9 - количество бомб в соседних клетках, сама клетка уже открыта
	\item 'F' - в клетке поставлен флаг
	\item 'X' - клетка закрыта от пользователя.
\end{itemize}

Нумерация для пользователя начинается 1, и ввод клетки также происходит с 1

Игрок может сделать только одно действие из перечня:
\begin{enumerate}
	\item Open - открыть клетку.
	\item Flag - поставить флаг.
	\item AI - запросить подсказку от АИ.
	\item Save - сохранить текущее положение игры.
	\item Exit - выйти из игры.
\end{enumerate}

В случае выбора Open или Flag игрок должен указать координаты клетки, с которой нужно произвести действия.
После каждого хода происходит проверка, выиграл ли игрок.
Если на карте открыты все ячейки, кроме бомб - то он выиграл, иначе игра продолжается.

По команде AI написанный мной алгоритм решения задачи подсказывает подходящее действие для текущего хода.

\chapter{Сохранение и загрузка игры}
Для работы с сохранениями используется библиотека pickle.
Она выбрана потому, что:
\begin{itemize}
	\item Имеется опыт работы с этой библиотекой.
	\item Пользователь не может узнать координаты, просто открыв файл.
\end{itemize}

Загрузку игры можно произвести только с главного меню, а сохранить игру - только во время игры.
В файл .pickle попадает информация о карте, её размеры, а также текущий счёт пользователя.
Пользователь при выполнении действий должен указать имя файла без расширения.
Все игры автоматически сохраняются в папку savings.

\chapter{AI}
Алгоритм для выбора состоит из двух этапов:
\begin{enumerate}
	\item Поиск точного решения задачи.
	\item Если точного решения нет - то найти клетку с минимальной вероятностью нахождения бомбы в клетке.
\end{enumerate}

Для первого пункта каждой открытой ячейке в соответствие ставится группа (Group): list из номеров ячеек, которые не открыты и находятся рядом.
Создаётся list из всех групп, который хранится у AI\_Manager.
После этого группы преобразовываются: каждая сравнивается с каждой. 
Все повторяющиеся группы удаляются, из множеств вычитаются подмножества, а пересекающиеся множества дробятся на три части.
Преобразования продолжаются до тех пор, пока изменять будет нечего.
После этого остаются три группы:

\begin{itemize}
	\item Группы, в которых количество мин == 0
	\item Группы, в которых количество мин == количеству бомб
	\item Остальные
\end{itemize}

Если есть хоть одна группа типа 1 или типа 2, то АИ сразу выдаёт решение.

Если же таких групп нет, то для каждой ячейки подсчитывается вероятность нахождения бомбы.
По формуле \ref{1.1} можно посчитать вероятность нахождения бомбы, зная вероятность нахождения бомбы из каждой группы, в которую входит ячейка.
\begin{math}
	\label{1.1}
	P = 1 - (1 - A_1) * (1 - A_2)..
\end{math}

Затем значения в каждой группе корректируются, учитывая, что сумма вероятностей по группе должна быть == 1.
В качестве ответа выбирается ячейка с минимальным значением вероятности.

Следует отметить, что АИ выиграла несколько простых игр, когда для тестирования я каждый раз выполнял команду, которую посоветует АИ.

Подробней алгоритм разобран на Хабре: https://habr.com/ru/post/211188/

Алгоритм отличается от исходного тем, что последние ходы не рассматриваются отдельно, а реализация сильно отличается от предложенного там варианта. 

\chapter{Структура классов}

\textbf{GameTable} - карта. Не принимает никаких решений, хранит матрицу значений для каждой из ячеек.

\textbf{GameKeeper} - сущность, которая хранит карту. Может расставлять объекты на карту, 
хранит все основные показатели игры (количество бомб, текущее число очков). При этом решений практически не принимает, 
кроме случайного распределения бомб. Может просить Shower вывести матрицу.

\textbf{GameManager} - сущность, которая передаёт инструкции по поводу игры (открыть ячейку, поставить флаг, показать счёт) от админа.
Связывает между собой админа и хранителя игры, который хранится как атрибут класса. 
Соответственно, на каждую игру создаётся свой менеджер

\textbf{GameHelper} - сущность, которая взаимодействует с игроком. Единственная сущность, которая что-то выводит на экран, а также принимает от пользователя параметры.

\textbf{GameAdmin} - сущность, которая принимает ключевые решения: какую создать игру, что вообще сделать. 
Создаётся при запуске программы, по сути - вершина всей структуры.
Владеет хелпером, и менеджером, которого каждый раз пересоздаёт при создании новой игры

\textbf{Solver} - сущность, которая просто возвращает True/False, является ли клетка бомбой. Практически не используется, роль минимальна

\textbf{Saver} - сущность, которая сохраняет игру.

\textbf{Loader} - сущность, которая загружает игру

\textbf{AI} - фасад для взаимодействия с АИ. Имеет только один метод - predict(). Говорит менеджеру, что нужно сделать

\textbf{AI\_Manager} - сущность, которая выполняет всю логику выбора правильного хода. Считает вероятности, выполняет действия с группами.

\textbf{Cell} - сущность ячейки. Практически не используется, как ни странно

\textbf{Group} - сущность группы, хранит все возможные операции, возможные с группой.

\chapter{Что стоило бы добавить или исправить}
Здесь перечислены вещи, которые я не успел сделать к дедлайну, но хотел:
\begin{itemize}
	\item Сделать генерацию карты после первого хода.
	\item Если вокруг ячейки нет бомб, то открыть все соседние (но тогда игра 5х5 может значительно упроститься).
	\item Добавить комментарии в код
	\item Изменить реализацию Cell, потому что там хранится атрибут вероятности, но фактически не используется
	\item Декомпозировать менеджера AI.
	\item На последнем ходу AI иногда советует не открыть, а поставить флаг.
	\item Сделать нормальную архитектуру/написать нормальный код.
	\item Сделать нормальную документацию (даже это я писал на скорую руку)
\end{itemize}
\end{document}